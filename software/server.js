/**
 * @file server.js
 * @fileoverview Weather server to receive data from the ESP, generate rain forecasts
 * via a Python script (XGBoost model) and store readings in a SQLite database.
 *
 * @version 1.0.0
 * @date 2025-08-29
 * @lastmodified 2025-11-26
 *
 * @author
 * Rafaela Fernandes Savaris <savarisf.rafaela@gmail.com>
 * Beatriz Schulter Tartare <beastartareufsc@gmail.com>
 *
 * @license Proprietary
 *
 * @requires express Creation of the server and definition of HTTP routes.
 * @requires cors Enables cross-origin requests (CORS).
 * @requires node-fetch Performs external requests (e.g., RSS feeds).
 * @requires node-cron Schedules periodic tasks (such as hourly forecast generation).
 * @requires child_process Executes Python scripts for forecasting.
 * @requires path File path manipulation.
 * @requires url Resolution of paths and URLs.
 * @requires ./src/db/database.js Module for SQLite database access.
 *
 * @description
 * This server receives meteorological readings sent by an ESP device,
 * processes and stores that data, generates rain forecasts with a Python model (XGBoost),
 * and exposes REST routes for querying data, history, and astronomical events.
 *
 * ### Main routes
 * - `GET /events` - Returns an RSS feed of astronomical events.
 * - `POST /data` - Receives data from the ESP and triggers an initial forecast.
 * - `POST /dados/refresh` - Forces generation of a new forecast.
 * - `GET /dados/ultimo` - Returns the latest record from the database.
 * - `GET /dados/historico` - Returns the requested number of records.
 * - `POST /cloudcover` - Updates current cloud coverage.
 *
 * ### Global variables
 * - `__filename`
 * - `__dirname`
 * - `ESPdata`
 * - `cloudCover`
 * - `lastPrediction`
 * - `lastUpdate`
 *
 * ### Main functions
 * - `waitCloudCover()` - Waits for cloud coverage to be defined.
 * - `generateFeatures()` - Generates meteorological features for forecasting.
 * - `generatePrediction(features = null)` - Runs the Python script and returns a rain forecast.
 * - `saveLastESPData(features = null)` - Saves readings and forecast to the database.
 *
 * ### Notes
 * - Includes automatic scheduling of hourly forecasts via node-cron.
 * - Requests are compatible with a React front-end and ESP using JSON.
 */

import { spawn } from "child_process";
import cors from "cors";
import express from "express";
import cron from "node-cron";
import fetch from "node-fetch";
import path from "path";
import { fileURLToPath } from "url";

import db from "./src/db/database.js";

/** @type {Express} */
const app = express();

/**
 * Enables Cross-Origin requests.
 */
app.use(cors());

/**
 * Port on which the server will listen.
 * @constant {number}
 */
const PORT = 4000;

/**
 * Enables JSON parsing in request bodies.
 */
app.use(express.json());

/**
 * Path of the current file (equivalent to CommonJS __filename).
 * @constant {string}
 */
const __filename = fileURLToPath(import.meta.url);

/**
 * Directory of the current file (equivalent to CommonJS __dirname).
 * @constant {string}
 */
const __dirname = path.dirname(__filename);

/**
 * Latest meteorological data received from the ESP.
 * @type {Object}
 */
let ESPdata = {};

/**
 * Current cloud coverage (cloudCover), updated via the /cloudcover route.
 * @type {number|null}
 */
let cloudCover = null;

/**
 * Last forecast generated by the Python model.
 * @type {Object|null}
 */
let lastPrediction = null;

/**
 * Timestamp of the last update received from the ESP, in milliseconds.
 * @type {number}
 */
let lastUpdate = 0;

/**
 * Last recorded precipitation.
 * @type {number}
 */
let lastPrecipitation = 0;

/**
 * Flag used to control whether the initial forecast is running.
 * @type {boolean}
 */
app.locals.runningInitialPrediction = false;

// ************************************* FUNCTIONS ************************************* //
/**
 * Waits until the global variable `cloudCover` is defined.
 * Performs checks every 1 second until a valid value is obtained.
 *
 * @function waitCloudCover
 * @async
 * @returns {Promise<number>} Returns a Promise that resolves with the value of "cloudCover"
 * as soon as it becomes defined.
 */
async function waitCloudCover() {
  const intervalo = 1000; // check every 1 second

  while (cloudCover == null) {
    console.log("Awaiting definition of Cloud Cover...");
    await new Promise((resolve) => setTimeout(resolve, intervalo));
  }

  return cloudCover;
}

/**
 * Generates the features required for forecasting and for saving into the database,
 * updating the value of the last recorded precipitation.
 *
 * The function waits until the `cloudCover` variable is defined, ensuring that all
 * necessary data is available. It then validates whether the data received from the
 * ESP device is present; if not, it throws an error.
 *
 * It stores the last recorded precipitation and returns an array containing the main
 * meteorological variables that will be used by the forecasting model and for database
 * insertion.
 *
 * @async
 * @function generateFeatures
 *
 * @returns {Promise<Array<number|string>>} A Promise that resolves with an array of
 * features, including atmospheric pressure, temperature, humidity, UV classification,
 * cloud coverage, and precipitation.
 *
 * @throws {Error} If `ESPdata` is not defined or is empty.
 *
 * @example
 * try {
 *   const features = await generateFeatures();
 *   console.log("Generated features:", features);
 * } catch (error) {
 *   console.error("Error generating features:", error.message);
 * }
 */
async function generateFeatures() {
  await waitCloudCover();

  if (!ESPdata || Object.keys(ESPdata).length === 0) {
    throw new Error("No ESP data available to generate features.");
  }

  return [
    ESPdata.pressure,
    ESPdata.temperature,
    ESPdata.humidity,
    ESPdata.uvIndex,
    cloudCover ?? 0, // cloudCover or 0 if undefined
    ESPdata.precipitation, // precipitation
  ];
}
/**
 * Generates a rain forecast based on the meteorological *features*, executing an external
 * Python script responsible for the prediction model.
 *
 * The function validates the provided *features*, normalizes the data, and, if the current
 * precipitation is greater than zero and different from the last recorded value, it sends the
 * values to the Python script (`server.py`) through a child process.
 *
 * The result returned by Python is read via *stdout*, parsed as JSON, and resolved as a
 * JavaScript object. The resulting forecast is stored in the global variable `lastPrediction`.
 *
 * In case of validation failure or an error during execution/parsing of the Python script,
 * the Promise is rejected with a descriptive message.
 *
 * @async
 * @function generatePrediction
 * @param {Array<number>} [features=null] - Array containing the meteorological *features*
 * required for prediction, in the following order:
 * `[pressure, temperature, humidity, uvIndex, cloudCover, precipitation]`.
 *
 * @returns {Promise<Object>} Returns a Promise that resolves with the forecast object generated
 * by the Python script, containing the model's results.
 *
 * @throws {Error} If the *features* are missing, invalid, or if an error occurs while interpreting
 * the Python script output.
 *
 * @example
 * try {
 *   const prediction = await generatePrediction(features);
 *   console.log("Generated prediction:", prediction);
 * } catch (error) {
 *   console.error("Error generating prediction:", error);
 * }
 */
async function generatePrediction(features = null) {
  return new Promise((resolve, reject) => {
    try {
      if (!features) {
        return reject("Sem dados atuais disponíveis");
      } else if (!Array.isArray(features) || features.length < 6) {
        return reject("Features inválidas para previsão");
      } else {
        const input = [
          features[0] * 0.01, // pressure_mbar
          features[1], // temperature
          features[2], // humidity
          0, // windSpeed
          0, // windDirection
          features[4], // cloudCover
        ];

        if (features[5] > 0 && features[5] != lastPrecipitation) {
          console.log("Precipitação detectada!");
          lastPrediction = { prediction: [[0, 1]] };
          lastPrecipitation = features[5];
          return resolve(lastPrediction);
        }
        features = input;
      }

      console.log("Generating forecasts with features:", features);

      const pyPath = path.join(__dirname, "src", "python", "server.py");
      const py = spawn("python", [pyPath]);

      let resultData = "";
      py.stdout.on("data", (data) => (resultData += data.toString()));
      py.stderr.on("data", (data) =>
        console.error("Python stderr:", data.toString())
      );

      py.on("close", (code) => {
        console.log(`Python process completed with code: ${code}`);
        try {
          const parsed = JSON.parse(resultData);
          lastPrediction = parsed;
          console.log("New prediction generated:", parsed);
          resolve(parsed);
        } catch (err) {
          console.error("Error interpreting Python output:", err, resultData);
          reject("Error interpreting model response.");
        }
      });

      py.stdin.write(JSON.stringify({ features }));
      py.stdin.end();
      lastPrecipitation = features[5];
    } catch (error) {
      console.error("Error generating prediction:", error);
      reject(error);
    }
  });
}

/**
 * Saves the latest meteorological readings and the associated rain prediction
 * into the database.
 *
 * The function validates the received *features* array, compares it with the last
 * saved record, and inserts a new entry only if there are significant changes.
 * The rain probability is obtained from the global variable `lastPrediction`.
 *
 * @async
 * @function saveLastESPData
 * @param {Array<number>} [features=null] - List of meteorological *features*, in the following order:
 * `[pressure, temperature, humidity, uvIndex, cloudCover, precipitation]`.
 *
 * @returns {Promise<void>} A Promise resolved after the save operation
 * (or skipped if the data is identical).
 *
 * @throws {Error} If a failure occurs while accessing or writing to the database.
 *
 * @example
 * await saveLastESPData([
 *   1013,   // pressure (atm)
 *   26.5,   // temperature
 *   70,     // humidity
 *   5,      // uvIndex
 *   40,     // cloudCover
 *   0       // precipitation
 * ]);
 */
async function saveLastESPData(features = null) {
  if (!features || !Array.isArray(features)) {
    console.log("No valid data received to save.");
    return;
  }

  // correct destructuring following the feature order
  const [pressure, temperature, humidity, uvIndex, cloudCover, precipitation] =
    features;

  // Retrieves the rain probability from the most recent forecast (fallback: 0 if unavailable)
  const probabilidadeChuva = lastPrediction?.prediction?.[0]?.[1] ?? 0;

  const last = db
    .prepare("SELECT * FROM weather_data_final ORDER BY id DESC LIMIT 1")
    .get();

  if (
    last &&
    last.temperature === temperature &&
    last.humidity === humidity &&
    last.pressure === pressure &&
    last.uvIndex === uvIndex &&
    last.cloudCover === cloudCover &&
    last.rainProbability === probabilidadeChuva &&
    last.precipitation === precipitation
  ) {
    console.log("Last record is the same, data was not saved.");
    return;
  }

  const stmt = db.prepare(`
    INSERT INTO weather_data_final (temperature, humidity, pressure, uvIndex, created_at, cloudCover, rainProbability, precipitation)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `);

  stmt.run(
    temperature,
    humidity,
    pressure,
    uvIndex,
    new Date().toISOString(),
    cloudCover,
    probabilidadeChuva,
    precipitation
  );

  console.log(`Saved data: ${new Date().toISOString()}`);
  const ultimo = db
    .prepare(
      `
    SELECT * FROM weather_data_final ORDER BY id DESC LIMIT 1
  `
    )
    .get();

  console.log("Saved data at database:", ultimo);
}

// ************************************* ROUTES *************************************** //
/**
 * @route GET /events
 * @summary Returns an RSS feed of astronomical events.
 *
 * This route performs an HTTP request to the public astronomical events feed
 * available at `https://in-the-sky.org/rss.php` and returns the received XML
 * content directly to the client. In case of a request failure, it returns an HTTP 500
 * status with an error message.
 *
 * @async
 * @function
 *
 * @param {express.Request} req - Express request object.
 * @param {express.Response} res - Express response object used to send the XML or error.
 *
 * @returns {void} The response is sent via `res.send()`, containing the XML feed content.
 *
 * @example
 * // Request:
 * GET /events
 *
 * // Successful response (200 OK):
 * <?xml version="1.0" encoding="UTF-8"?>
 * <rss version="2.0">
 *   <channel>
 *     <title>Astronomical Events</title>
 *     <item>
 *       <title>Conjunction of the Moon with Mars</title>
 *       <pubDate>Fri, 08 Nov 2025 03:00:00 GMT</pubDate>
 *       ...
 *     </item>
 *   </channel>
 * </rss>
 *
 * // Error response (500 Internal Server Error):
 * {
 *   "error": "Failed to fetch astronomical events feed."
 * }
 */
app.get("/events", async (req, res) => {
  try {
    const response = await fetch("https://in-the-sky.org/rss.php");
    const text = await response.text();
    res.send(text);
  } catch (err) {
    res.status(500).send({ error: err.message });
  }
});

/**
 * @route POST /cloudcover
 * @summary Updates the cloud cover value (*cloudCover*).
 *
 * Receives a cloud cover value in the request body (`req.body.cloudCover`)
 * and updates it in the global variable `cloudCover`.
 * Returns the new defined value, or an error if the field is not provided.
 *
 * @param {express.Request} req - Express request object containing `cloudCover` in the request body.
 * @param {express.Response} res - Express response object used to send the status and return JSON.
 *
 * @returns {void} The response is sent directly via `res.json()`.
 *
 * @example
 * // Request (JSON):
 * {
 *   "cloudCover": 75
 * }
 *
 * // Response (200 OK):
 * {
 *   "ok": true,
 *   "cloudCover": 75
 * }
 *
 * // Response (400 Bad Request):
 * {
 *   "error": "cloudCover not provided"
 * }
 */
app.post("/cloudcover", (req, res) => {
  const { cloudCover: newValue } = req.body;

  if (newValue == null) {
    return res.status(400).json({ error: "Cloud Cover not provided" });
  }
  cloudCover = newValue;
  res.json({ ok: true, cloudCover });
});

/**
 * @route POST /data
 * @summary Receives meteorological data from the ESP device and starts generating the initial prediction.
 *
 * This route is called by the ESP device to send meteorological readings.
 * Upon receiving the data, the server:
 * 1. Prevents duplicate updates within an interval shorter than 5 seconds;
 * 2. Stores the received data in `ESPdata`;
 * 3. Returns an immediate response (`{ ok: true }`);
 * 4. Asynchronously executes the `generateFeatures` function, saving the result in the local variable `features`;
 * 5. Also asynchronously runs the initial prediction process by calling the Python model (`generatePrediction`)
 *    and saving the result in the database (via the `saveLastESPData` module).
 *
 * The execution of the initial prediction is controlled by internal flags
 * (`app.locals.runningInitialPrediction` and `app.locals.firstConnection`)
 * to avoid multiple simultaneous executions.
 *
 * @async
 * @function
 *
 * @param {express.Request} req - Express request object containing the meteorological data sent by the ESP in the body (`req.body`).
 * @param {express.Response} res - Express response object used to send the status and JSON confirmation.
 *
 * @returns {void} The response is sent via `res.json()`. In case of an error during prediction generation, the error is only logged to the console.
 *
 * @example
 * // Request:
 * POST /dados
 * Content-Type: application/json
 * {
 *   "temperature": 23.5,
 *   "humidity": 82,
 *   "pressure": 1011,
 *   "uvIndex": "Baixa",
 *   "precipitation": 0.2
 * }
 *
 * // Immediate response (200 OK):
 * {
 *   "ok": true
 * }
 *
 * // Example of ignored (duplicate) response:
 * {
 *   "ok": true,
 *   "ignored": true
 * }
 */
app.post("/data", async (req, res) => {
  const now = Date.now();
  if (now - lastUpdate < 5000) {
    console.log("Ignoring duplicate update/data");
    return res.status(200).json({ ok: true, ignored: true });
  }
  lastUpdate = now;

  ESPdata = req.body;
  res.json({ ok: true });

  if (app.locals.runningInitialPrediction) {
    return;
  }

  if (app.locals.firstConnection) {
    return;
  }

  app.locals.runningInitialPrediction = true;
  console.log("Generating initial forecast...");

  try {
    const features = await generateFeatures();
    await generatePrediction(features);
    await saveLastESPData(features);
    app.locals.firstConnection = true;
  } catch (err) {
    console.error("Error generating initial forecast:", err);
  } finally {
    app.locals.runningInitialPrediction = false;
  }
});

/**
 * @route POST /dados/refresh
 * @summary Generates a new rain prediction based on the current meteorological data from the ESP.
 *
 * This route forces an update of the rain prediction using the most recent *features*
 * stored in `ESPdata`. Before starting, it checks whether a prediction is already running
 * to prevent server overload. If no prediction is in progress:
 * 1. The *features* are generated via `generateFeatures()`;
 * 2. The Python model is called to generate the prediction (`generatePrediction()`);
 * 3. The data and prediction are saved to the database (`saveLastESPData()`).
 *
 * @async
 * @function
 *
 * @param {express.Request} req - Express request object. Meteorological data may be sent in the body (`req.body`), but it is not mandatory.
 * @param {express.Response} res - Express response object used to send status and JSON results.
 *
 * @returns {void} The response is sent via `res.json()`. In case of error, returns HTTP status 500 with a descriptive message. If a prediction is already running, returns 429.
 *
 * @example
 * // Request:
 * POST /dados/refresh
 *
 * // Success response (200 OK):
 * {
 *   "ok": true,
 *   "prediction_generated": {
 *     "prediction": 0.42,
 *     "timestamp": "2025-11-07T12:00:00.000Z"
 *   }
 * }
 *
 * // Response when a prediction is already running (429):
 * {
 *   "error": "Prediction in progress, please try again."
 * }
 *
 * // Generic error response (500):
 * {
 *   "error": "Error generating prediction or saving data"
 * }
 */
app.post("/dados/refresh", async (req, res) => {
  try {
    if (app.locals.runningPrediction) {
      return res
        .status(429)
        .json({ error: "Prediction in progress, please try again." });
    }

    app.locals.runningPrediction = true;

    const features = await generateFeatures();

    const prediction_generated = await generatePrediction(features);
    await saveLastESPData(features);
    res.json({ ok: true, prediction_generated });
  } catch (err) {
    console.error("Refresh error:", err);
    res.status(500).json({ error: "Error generating forecast or saving data." });
  } finally {
    app.locals.runningPrediction = false;
  }
});

/**
 * @route GET /dados/ultimo
 * @summary Returns the most recent record of meteorological readings stored in the database.
 *
 * This route queries the `dados_estacao_metereologica` table in the SQLite database and returns
 * the latest record in JSON format. It is used by the front-end to obtain the current ESP device data,
 * including temperature, humidity, atmospheric pressure, UV, cloud cover, rain probability, etc.
 *
 * In case of a database query failure, the route returns an HTTP 500 status with a generic error message.
 *
 * @param {express.Request} req - Express request object.
 * @param {express.Response} res - Express response object used to send the record or the error.
 *
 * @returns {void} The response is sent directly via `res.json()`.
 *
 * @example
 * // Request:
 * GET /dados/ultimo
 *
 * // Successful response (200 OK):
 * {
 *   "id": 42,
 *   "temperature": 25.5,
 *   "humidity": 80,
 *   "pressure": 1012,
 *   "uvIndex": 3,
 *   "cloudCover": 60,
 *   "rainProbability": 0.35,
 *   "precipitation": 0,
 *   "created_at": "2025-11-07T12:15:00.000Z"
 * }
 *
 * // Error response (500 Internal Server Error):
 * {
 *   "error": "Error fetching latest data."
 * }
 */
app.get("/dados/ultimo", (req, res) => {
  try {
    const lastData = db
      .prepare(
        `
      SELECT * FROM weather_data_final
      ORDER BY datetime(created_at) DESC
      LIMIT 1
    `
      )
      .get();

    res.json(lastData);
  } catch (error) {
    console.error("Error fetching latest data:", error);
    res.status(500).json({ error: "Error fetching latest data." });
  }
});

/**
 * @route GET /dados/historico
 * @summary Returns historical records of meteorological readings with pagination support.
 *
 * This route queries the `dados_estacao_metereologica` table in the SQLite database and returns
 * a set of records ordered from newest to oldest.
 *
 * The user can control the number of returned items and the starting point of the query
 * using the query parameters `limit` and `offset`.
 *
 * - `limit` (optional): maximum number of records to be returned.
 *   - Default value: **50**
 * - `offset` (optional): how many records should be skipped before results start being returned.
 *   - Default value: **0**
 *
 * In case of an error during the database query, the route returns an HTTP 500 status
 * with a generic message, avoiding exposure of internal details.
 *
 * @param {express.Request} req - Express request object containing `req.query.limit` and `req.query.offset`.
 * @param {express.Response} res - Express response object used to send data or errors.
 *
 * @returns {void} The response is sent directly via `res.json()`.
 *
 * @example
 * // Simple request:
 * GET /dados/historico
 *
 * // Equivalent to:
 * GET /dados/historico?limit=50&offset=0
 *
 * // Successful response (200 OK):
 * [
 *   {
 *     "id": 71,
 *     "temperature": 23.1,
 *     "humidity": 62,
 *     "pressure": 1015,
 *     "uvIndex": 3,
 *     "cloudCover": 0.4,
 *     "rainProbability": 0.1,
 *     "precipitation": 0,
 *     "created_at": "2025-11-26T12:10:00.000Z"
 *   },
 *   ...
 * ]
 *
 * @example
 * // Paginated request (20 per page):
 * GET /dados/historico?limit=20&offset=20
 *
 * // Error response (500 Internal Server Error):
 * {
 *   "error": "Error fetching history."
 * }
 */
app.get("/dados/historico", (req, res) => {
  const limit = parseInt(req.query.limit) || 50;
  const offset = parseInt(req.query.offset) || 0;

  try {
    const rows = db
      .prepare(
        "SELECT * FROM weather_data_final ORDER BY id DESC LIMIT ? OFFSET ?"
      )
      .all(limit, offset);
    res.json(rows);
  } catch (error) {
    console.error("Error fetching history:", error.message);
    res.status(500).json({ error: "Error fetching history." });
  }
});

/**
 * Scheduled task responsible for generating and saving weather forecasts every full hour.
 *
 * This function is automatically executed by `node-cron` at the zero minute of each hour.
 * The task flow is:
 * 1. Generates the current weather *features* by calling `generateFeatures()`.
 * 2. Runs the Python prediction model via `generatePrediction(features)`.
 * 3. Saves the readings and the forecast into the database using `saveLastESPData(features)`.
 *
 * If an error occurs at any step, it is logged to the console.
 *
 * @async
 *
 * @example
 * // Example of automatic execution:
 * // In cron: "0 * * * *": runs every day, at the beginning of each hour.
 * // Expected console output:
 * Generating scheduled forecast...
 * New forecast generated: { ... }
 * Prediction and data successfully saved at peak time.
 *
 * // In case of error:
 * Error generating scheduled prediction: [Error details]
 */
cron.schedule("0 * * * *", async () => {
  console.log("Generating new scheduled prediction...");
  try {
    const features = await generateFeatures();

    // generates the forecast using the current data
    await generatePrediction(features);

    // saves the data + forecast
    await saveLastESPData(features);

    console.log("Prediction and data successfully saved at peak time.");
  } catch (err) {
    console.error("Error generating scheduled prediction:", err);
  }
});

/**
 * Initializes the Express server and starts task scheduling.
 *
 * The server listens on the port defined in `PORT` and on the address "0.0.0.0",
 * allowing access across the entire local network. Upon starting, it logs a message
 * to the console confirming that the server is active.
 *
 * It also indicates that the hourly forecast-saving schedule
 * has already been started by the cron.
 *
 * @example
 * // Expected console output after starting the server:
 * Server running on the network on port 4000
 * Hourly full-hour saving schedule started
 */
app.listen(PORT, "0.0.0.0", () => {
  console.log(`Server running on the network on port ${PORT}`);
});
console.log("Hourly backup scheduling initiated");
