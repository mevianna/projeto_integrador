/**
 * @file server.js
 * @fileoverview Weather server to receive data from the ESP, generate rain forecasts
 * via a Python script (XGBoost model) and store readings in a SQLite database.
 *
 * @version 1.0.0
 * @date 2025-08-29
 * @lastmodified 2025-11-26
 *
 * @author
 * Rafaela Fernandes Savaris <savarisf.rafaela@gmail.com>
 * Beatriz Schulter Tartare <beastartareufsc@gmail.com>
 *
 * @license Proprietary
 *
 * @requires express Creation of the server and definition of HTTP routes.
 * @requires cors Enables cross-origin requests (CORS).
 * @requires node-fetch Performs external requests (e.g., RSS feeds).
 * @requires node-cron Schedules periodic tasks (such as hourly forecast generation).
 * @requires child_process Executes Python scripts for forecasting.
 * @requires path File path manipulation.
 * @requires url Resolution of paths and URLs.
 * @requires ./src/db/database.js Module for SQLite database access.
 *
 * @description
 * This server receives meteorological readings sent by an ESP device,
 * processes and stores that data, generates rain forecasts with a Python model (XGBoost),
 * and exposes REST routes for querying data, history, and astronomical events.
 *
 * ### Main routes
 * - `GET /events` - Returns an RSS feed of astronomical events.
 * - `POST /dados` - Receives data from the ESP and triggers an initial forecast.
 * - `POST /dados/refresh` - Forces generation of a new forecast.
 * - `GET /dados/ultimo` - Returns the latest record from the database.
 * - `GET /dados/historico` - Returns the requested number of records.
 * - `POST /cloudcover` - Updates current cloud coverage.
 *
 * ### Global variables
 * - `__filename`
 * - `__dirname`
 * - `dadosESP`
 * - `cloudCover`
 * - `ultimaPrevisao`
 * - `ultimaAtualizacao`
 *
 * ### Main functions
 * - `esperarCloudCover()` - Waits for cloud coverage to be defined.
 * - `gerarFeatures()` - Generates meteorological features for forecasting.
 * - `gerarPrevisao(features = null)` - Runs the Python script and returns a rain forecast.
 * - `salvarUltimoDado(features = null)` - Saves readings and forecast to the database.
 *
 * ### Notes
 * - Includes automatic scheduling of hourly forecasts via node-cron.
 * - Requests are compatible with a React front-end and ESP using JSON.
 */

import { spawn } from "child_process";
import cors from "cors";
import express from "express";
import cron from "node-cron";
import fetch from "node-fetch";
import path from "path";
import { fileURLToPath } from "url";

import db from "./src/db/database.js";

/** @type {Express} */
const app = express();

/**
 * Enables Cross-Origin requests.
 */
app.use(cors());

/**
 * Port on which the server will listen.
 * @constant {number}
 */
const PORT = 4000;

/**
 * Enables JSON parsing in request bodies.
 */
app.use(express.json());

/**
 * Path of the current file (equivalent to CommonJS __filename).
 * @constant {string}
 */
const __filename = fileURLToPath(import.meta.url);

/**
 * Directory of the current file (equivalent to CommonJS __dirname).
 * @constant {string}
 */
const __dirname = path.dirname(__filename);

/**
 * Latest meteorological data received from the ESP.
 * @type {Object}
 */
let dadosESP = {};

/**
 * Current cloud coverage (cloudCover), updated via the /cloudcover route.
 * @type {number|null}
 */
let cloudCover = null;

/**
 * Last forecast generated by the Python model.
 * @type {Object|null}
 */
let ultimaPrevisao = null;

/**
 * Timestamp of the last update received from the ESP, in milliseconds.
 * @type {number}
 */
let ultimaAtualizacao = 0;

/**
 * Last recorded precipitation.
 * @type {number}
 */
let ultimaPrecipitacao = 0;

/**
 * Flag used to control whether the initial forecast is running.
 * @type {boolean}
 */
app.locals.executandoPrevisaoInicial = false;

// ************************************* FUNCTIONS ************************************* //
/**
 * Waits until the global variable `cloudCover` is defined.
 * Performs checks every 1 second until a valid value is obtained.
 *
 * @function esperarCloudCover
 * @async
 * @returns {Promise<number>} Returns a Promise that resolves with the value of "cloudCover"
 * as soon as it becomes defined.
 */

async function esperarCloudCover() {
  const intervalo = 1000; // checa a cada 1 segundo

  while (cloudCover == null) {
    console.log("Aguardando definição de cloudCover...");
    await new Promise((resolve) => setTimeout(resolve, intervalo));
  }

  return cloudCover;
}

/**
 * Generates the features required for forecasting and for saving into the database,
 * updating the value of the last recorded precipitation.
 *
 * The function waits until the `cloudCover` variable is defined, ensuring that all
 * necessary data is available. It then validates whether the data received from the
 * ESP device is present; if not, it throws an error.
 *
 * It stores the last recorded precipitation and returns an array containing the main
 * meteorological variables that will be used by the forecasting model and for database
 * insertion.
 *
 * @async
 * @function gerarFeatures
 *
 * @returns {Promise<Array<number|string>>} A Promise that resolves with an array of
 * features, including atmospheric pressure, temperature, humidity, UV classification,
 * cloud coverage, and precipitation.
 *
 * @throws {Error} If `dadosESP` is not defined or is empty.
 *
 * @example
 * try {
 *   const features = await gerarFeatures();
 *   console.log("Generated features:", features);
 * } catch (error) {
 *   console.error("Error generating features:", error.message);
 * }
 */

async function gerarFeatures() {
  await esperarCloudCover();

  if (!dadosESP || Object.keys(dadosESP).length === 0) {
    throw new Error("Nenhum dado do ESP disponível para gerar features.");
  }

  return [
    dadosESP.pressaoAtm,
    dadosESP.temperatura,
    dadosESP.umidade,
    dadosESP.uvClassificacao,
    cloudCover ?? 0, // cloudCover or 0 if undefined
    dadosESP.precipitacao, // precipitation
  ];
}
/**
 * Generates a rain forecast based on the meteorological *features*, executing an external
 * Python script responsible for the prediction model.
 *
 * The function validates the provided *features*, normalizes the data, and, if the current
 * precipitation is greater than zero and different from the last recorded value, it sends the
 * values to the Python script (`server.py`) through a child process.
 *
 * The result returned by Python is read via *stdout*, parsed as JSON, and resolved as a
 * JavaScript object. The resulting forecast is stored in the global variable `ultimaPrevisao`.
 *
 * In case of validation failure or an error during execution/parsing of the Python script,
 * the Promise is rejected with a descriptive message.
 *
 * @async
 * @function gerarPrevisao
 * @param {Array<number>} [features=null] - Array containing the meteorological *features*
 * required for prediction, in the following order:
 * `[pressaoAtm, temperatura, umidade, uvClassificacao, cloudCover, precipitacao]`.
 *
 * @returns {Promise<Object>} Returns a Promise that resolves with the forecast object generated
 * by the Python script, containing the model's results.
 *
 * @throws {Error} If the *features* are missing, invalid, or if an error occurs while interpreting
 * the Python script output.
 *
 * @example
 * try {
 *   const previsao = await gerarPrevisao(features);
 *   console.log("Generated forecast:", previsao);
 * } catch (error) {
 *   console.error("Error generating forecast:", error);
 * }
 */

async function gerarPrevisao(features = null) {
  return new Promise((resolve, reject) => {
    try {
      if (!features) {
        return reject("Sem dados atuais disponíveis");
      } else if (!Array.isArray(features) || features.length < 6) {
        return reject("Features inválidas para previsão");
      } else {
        const input = [
          features[0] * 0.01, // pressure_mbar
          features[1], // temperature
          features[2], // humidity
          0, // windSpeed
          0, // windDirection
          features[4], // cloudCover
        ];

        if (features[5] > 0 && features[5] != ultimaPrecipitacao) {
          console.log("Precipitação detectada!");
          ultimaPrevisao = { prediction: [[0, 1]] };
          ultimaPrecipitacao = features[5];
          return resolve(ultimaPrevisao);
        }
        features = input;
      }

      console.log("Gerando previsão com features:", features);

      const pyPath = path.join(__dirname, "src", "python", "server.py");
      const py = spawn("python", [pyPath]);

      let resultData = "";
      py.stdout.on("data", (data) => (resultData += data.toString()));
      py.stderr.on("data", (data) =>
        console.error("Python stderr:", data.toString())
      );

      py.on("close", (code) => {
        console.log(`Processo Python finalizado com código: ${code}`);
        try {
          const parsed = JSON.parse(resultData);
          ultimaPrevisao = parsed;
          console.log("Nova previsão gerada:", parsed);
          resolve(parsed);
        } catch (err) {
          console.error("Erro ao interpretar saída Python:", err, resultData);
          reject("Erro ao interpretar resposta do modelo");
        }
      });

      py.stdin.write(JSON.stringify({ features }));
      py.stdin.end();
      ultimaPrecipitacao = features[5];
    } catch (error) {
      console.error("Erro ao gerar previsão:", error);
      reject(error);
    }
  });
}

/**
 * Saves the latest meteorological readings and the associated rain prediction
 * into the database.
 *
 * The function validates the received *features* array, compares it with the last
 * saved record, and inserts a new entry only if there are significant changes.
 * The rain probability is obtained from the global variable `ultimaPrevisao`.
 *
 * @async
 * @function salvarUltimoDado
 * @param {Array<number>} [features=null] - List of meteorological *features*, in the following order:
 * `[pressaoAtm, temperatura, umidade, uvClassificacao, cloudCover, precipitacao]`.
 *
 * @returns {Promise<void>} A Promise resolved after the save operation
 * (or skipped if the data is identical).
 *
 * @throws {Error} If a failure occurs while accessing or writing to the database.
 *
 * @example
 * await salvarUltimoDado([
 *   1013,   // pressaoAtm
 *   26.5,   // temperatura
 *   70,     // umidade
 *   5,      // uvClassificacao
 *   40,     // cloudCover
 *   0       // precipitacao
 * ]);
 */
async function salvarUltimoDado(features = null) {
  if (!features || !Array.isArray(features)) {
    console.log("No valid data received to save.");
    return;
  }

  // correct destructuring following the feature order
  const [
    pressaoAtm,
    temperatura,
    umidade,
    uvClassificacao,
    cloud,
    precipitacao,
  ] = features;

  // Retrieves the rain probability from the most recent forecast (fallback: 0 if unavailable)
  const probabilidadeChuva = ultimaPrevisao?.prediction?.[0]?.[1] ?? 0;

  const last = db
    .prepare(
      "SELECT * FROM dados_estacao_metereologica ORDER BY id DESC LIMIT 1"
    )
    .get();

  if (
    last &&
    last.temperatura === temperatura &&
    last.umidade === umidade &&
    last.pressaoAtm === pressaoAtm &&
    last.uvClassificacao === uvClassificacao &&
    last.cloudCover === cloud &&
    last.rainProbability === probabilidadeChuva &&
    last.precipitacao === precipitacao
  ) {
    console.log("Último registro é igual, não salvou");
    return;
  }

  const stmt = db.prepare(`
    INSERT INTO dados_estacao_metereologica (temperatura, umidade, pressaoAtm, uvClassificacao, created_at, cloudCover, rainProbability, precipitacao)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `);

  stmt.run(
    temperatura,
    umidade,
    pressaoAtm,
    uvClassificacao,
    new Date().toISOString(),
    cloud,
    probabilidadeChuva,
    precipitacao
  );

  console.log(`Salvou dado: ${new Date().toISOString()}`);
  const ultimo = db
    .prepare(
      `
    SELECT * FROM dados_estacao_metereologica ORDER BY id DESC LIMIT 1
  `
    )
    .get();

  console.log("Dado salvo no banco:", ultimo);
}

// ************************************* ROTAS *************************************** //
/**
 * @route GET /events
 * @summary Retorna um feed RSS de eventos astronômicos.
 *
 * Esta rota realiza uma requisição HTTP para o feed público de eventos astronômicos
 * disponível em `https://in-the-sky.org/rss.php` e retorna o conteúdo XML recebido
 * diretamente ao cliente. Em caso de falha na requisição, retorna um status HTTP 500 com uma mensagem de erro.
 *
 * @async
 * @function
 *
 * @param {express.Request} req - Objeto da requisição Express.
 * @param {express.Response} res - Objeto da resposta Express usada para enviar o XML ou o erro.
 *
 * @returns {void} A resposta é enviada via `res.send()`, contendo o conteúdo XML do feed.
 *
 * @example
 * // Requisição:
 * GET /events
 *
 * // Resposta de sucesso (200 OK):
 * <?xml version="1.0" encoding="UTF-8"?>
 * <rss version="2.0">
 *   <channel>
 *     <title>Astronomical Events</title>
 *     <item>
 *       <title>Conjunção da Lua com Marte</title>
 *       <pubDate>Fri, 08 Nov 2025 03:00:00 GMT</pubDate>
 *       ...
 *     </item>
 *   </channel>
 * </rss>
 *
 * // Resposta de erro (500 Internal Server Error):
 * {
 *   "error": "Failed to fetch astronomical events feed."
 * }
 */
app.get("/events", async (req, res) => {
  try {
    const response = await fetch("https://in-the-sky.org/rss.php");
    const text = await response.text();
    res.send(text);
  } catch (err) {
    res.status(500).send({ error: err.message });
  }
});

/**
 * @route POST /cloudcover
 * @summary Atualiza o valor da cobertura de nuvens (*cloudCover*).
 *
 * Recebe um valor de cobertura de nuvens no corpo da requisição (`req.body.cloudCover`)
 * e o atualiza na variável global `cloudCover`.
 * Retorna o novo valor definido, ou um erro caso o campo não seja enviado.
 *
 * @param {express.Request} req - Objeto da requisição Express contendo `cloudCover` no corpo (`body`).
 * @param {express.Response} res - Objeto da resposta Express usado para enviar o status e o JSON de retorno.
 *
 * @returns {void} A resposta é enviada diretamente via `res.json()`.
 *
 * @example
 * // Requisição (JSON):
 * {
 *   "cloudCover": 75
 * }
 *
 * // Resposta (200 OK):
 * {
 *   "ok": true,
 *   "cloudCover": 75
 * }
 *
 * // Resposta (400 Bad Request):
 * {
 *   "error": "cloudCover não enviado"
 * }
 */
app.post("/cloudcover", (req, res) => {
  const { cloudCover: novoValor } = req.body;

  if (novoValor == null) {
    return res.status(400).json({ error: "cloudCover não enviado" });
  }
  cloudCover = novoValor;
  res.json({ ok: true, cloudCover });
});

/**
 * @route POST /dados
 * @summary Recebe dados meteorológicos do dispositivo ESP e inicia a geração de previsão inicial.
 *
 * Esta rota é chamada pelo dispositivo ESP para enviar leituras meteorológicas.
 * Ao receber os dados, o servidor:
 * 1. Evita atualizações duplicadas em um intervalo menor que 5 segundos;
 * 2. Armazena os dados recebidos em `dadosESP`;
 * 3. Retorna uma resposta imediata (`{ ok: true }`);
 * 4. Executa, de forma assíncrona, a chamada da função `gerarFeatures`, salvando na variável local `features`
 * 5. Realiza, também de forma assíncrona, o processo de previsão inicial, chamando o modelo Python (a função `gerarPrevisao`)
 *    e salvando o resultado no banco (o módulo `salvarUltimoDado`).
 *
 * A execução da previsão inicial é controlada por flags internas (`app.locals.executandoPrevisaoInicial`
 * e `app.locals.primeiraConexao`) para evitar múltiplas execuções simultâneas.
 *
 * @async
 * @function
 *
 * @param {express.Request} req - Objeto da requisição Express contendo os dados meteorológicos enviados pelo ESP no corpo (`req.body`).
 * @param {express.Response} res - Objeto da resposta Express usado para enviar o status e a confirmação em JSON.
 *
 * @returns {void} A resposta é enviada via `res.json()`. Em caso de erro na geração da previsão, o erro é apenas registrado no console.
 *
 * @example
 * // Requisição:
 * POST /dados
 * Content-Type: application/json
 * {
 *   "temperatura": 23.5,
 *   "umidade": 82,
 *   "pressaoAtm": 1011,
 *   "uvClassificacao": "Baixa",
 *   "precipitacao": 0.2
 * }
 *
 * // Resposta imediata (200 OK):
 * {
 *   "ok": true
 * }
 *
 * // Exemplo de resposta ignorada (duplicada):
 * {
 *   "ok": true,
 *   "ignorado": true
 * }
 */
app.post("/dados", async (req, res) => {
  const agora = Date.now();
  if (agora - ultimaAtualizacao < 5000) {
    console.log("Ignorando atualização duplicada /dados");
    return res.status(200).json({ ok: true, ignorado: true });
  }
  ultimaAtualizacao = agora;

  dadosESP = req.body;
  res.json({ ok: true });

  if (app.locals.executandoPrevisaoInicial) {
    return;
  }

  if (app.locals.primeiraConexao) {
    return;
  }

  app.locals.executandoPrevisaoInicial = true;
  console.log("Gerando previsão inicial...");

  try {
    const features = await gerarFeatures();
    await gerarPrevisao(features);
    await salvarUltimoDado(features);
    app.locals.primeiraConexao = true;
  } catch (err) {
    console.error("Erro ao gerar previsão inicial:", err);
  } finally {
    app.locals.executandoPrevisaoInicial = false;
  }
});

/**
 * @route POST /dados/refresh
 * @summary Gera uma nova previsão de chuva com base nos dados meteorológicos atuais do ESP.
 *
 * Esta rota força a atualização da previsão de chuva usando as *features* mais recentes
 * armazenadas em `dadosESP`. Antes de iniciar, verifica se já existe uma previsão em execução
 * para evitar sobrecarga do servidor. Caso não haja previsão em andamento:
 * 1. As *features* são geradas via `gerarFeatures()`;
 * 2. O modelo Python é chamado para gerar a previsão (`gerarPrevisao()`);
 * 3. Os dados e a previsão são salvos no banco (`salvarUltimoDado()`).
 *
 * @async
 * @function
 *
 * @param {express.Request} req - Objeto da requisição Express. Os dados meteorológicos podem ser enviados no corpo (`req.body`), mas não são obrigatórios.
 * @param {express.Response} res - Objeto da resposta Express usado para enviar status e resultado em JSON.
 *
 * @returns {void} A resposta é enviada via `res.json()`. Em caso de erro, retorna status HTTP 500 com uma mensagem descritiva. Se já houver previsão em execução, retorna 429.
 *
 * @example
 * // Requisição:
 * POST /dados/refresh
 *
 * // Resposta de sucesso (200 OK):
 * {
 *   "ok": true,
 *   "previsao": {
 *     "prediction": 0.42,
 *     "timestamp": "2025-11-07T12:00:00.000Z"
 *   }
 * }
 *
 * // Resposta se previsão já estiver em execução (429):
 * {
 *   "error": "Previsão em execução, tente novamente."
 * }
 *
 * // Resposta de erro genérico (500):
 * {
 *   "error": "Erro ao gerar previsão ou salvar dado"
 * }
 */
app.post("/dados/refresh", async (req, res) => {
  try {
    if (app.locals.executandoPrevisao) {
      return res
        .status(429)
        .json({ error: "Previsão em execução, tente novamente." });
    }

    app.locals.executandoPrevisao = true;

    const features = await gerarFeatures();

    const previsao = await gerarPrevisao(features);
    await salvarUltimoDado(features);
    res.json({ ok: true, previsao });
  } catch (err) {
    console.error("Erro no refresh:", err);
    res.status(500).json({ error: "Erro ao gerar previsão ou salvar dado" });
  } finally {
    app.locals.executandoPrevisao = false;
  }
});

/**
 * @route GET /dados/ultimo
 * @summary Retorna o último registro de leituras meteorológicas armazenadas no banco de dados.
 *
 * Esta rota consulta a tabela `dados_estacao_metereologica` do banco SQLite e retorna o registro mais recente
 * em formato JSON. É usada pelo front-end para obter os dados atuais do dispositivo ESP,
 * incluindo temperatura, umidade, pressão atmosférica, UV, cobertura de nuvens, probabilidade de chuva, etc.
 *
 * Em caso de falha na consulta ao banco, a rota retorna um status HTTP 500 com uma mensagem de erro genérica.
 *
 * @param {express.Request} req - Objeto da requisição Express.
 * @param {express.Response} res - Objeto da resposta Express usado para enviar o registro ou o erro.
 *
 * @returns {void} A resposta é enviada diretamente via `res.json()`.
 *
 * @example
 * // Requisição:
 * GET /dados/ultimo
 *
 * // Resposta de sucesso (200 OK):
 * {
 *   "id": 42,
 *   "temperatura": 25.5,
 *   "umidade": 80,
 *   "pressaoAtm": 1012,
 *   "uvClassificacao": 3,
 *   "cloudCover": 60,
 *   "rainProbability": 0.35,
 *   "precipitacao": 0,
 *   "created_at": "2025-11-07T12:15:00.000Z"
 * }
 *
 * // Resposta de erro (500 Internal Server Error):
 * {
 *   "error": "Erro ao buscar último dado"
 * }
 */
app.get("/dados/ultimo", (req, res) => {
  try {
    const ultimoDado = db
      .prepare(
        `
      SELECT * FROM dados_estacao_metereologica
      ORDER BY datetime(created_at) DESC
      LIMIT 1
    `
      )
      .get();

    res.json(ultimoDado);
  } catch (error) {
    console.error("Erro ao buscar último dado:", error);
    res.status(500).json({ error: "Erro ao buscar último dado" });
  }
});

/**
 * @route GET /dados/historico
 * @summary Retorna registros históricos de leituras meteorológicas com suporte a paginação.
 *
 * Esta rota consulta a tabela `dados_estacao_metereologica` no banco SQLite e retorna
 * um conjunto de registros ordenados do mais recente para o mais antigo.
 *
 * O usuário pode controlar a quantidade de itens retornados e o ponto de início da busca
 * usando os parâmetros de query `limit` e `offset`.
 *
 * - `limit` (opcional): quantidade máxima de registros a serem retornados.
 *   - Valor padrão: **50**
 * - `offset` (opcional): quantos registros devem ser ignorados antes de começar a retornar resultados.
 *   - Valor padrão: **0**
 *
 * Em caso de erro na consulta ao banco, a rota retorna status HTTP 500 com uma mensagem
 * genérica, evitando exposição de detalhes internos.
 *
 * @param {express.Request} req - Objeto da requisição Express contendo `req.query.limit` e `req.query.offset`.
 * @param {express.Response} res - Objeto de resposta Express usado para enviar dados ou erros.
 *
 * @returns {void} A resposta é enviada diretamente via `res.json()`.
 *
 * @example
 * // Requisição simples:
 * GET /dados/historico
 *
 * // Equivalente a:
 * GET /dados/historico?limit=50&offset=0
 *
 * // Resposta (200 OK):
 * [
 *   {
 *     "id": 71,
 *     "temperatura": 23.1,
 *     "umidade": 62,
 *     "pressaoAtm": 1015,
 *     "uvClassificacao": 3,
 *     "cloudCover": 0.4,
 *     "rainProbability": 0.1,
 *     "precipitacao": 0,
 *     "created_at": "2025-11-26T12:10:00.000Z"
 *   },
 *   ...
 * ]
 *
 * @example
 * // Requisição paginada (20 por página):
 * GET /dados/historico?limit=20&offset=20
 *
 * // Resposta de erro (500 Internal Server Error):
 * {
 *   "error": "Erro ao buscar histórico de leituras."
 * }
 */
app.get("/dados/historico", (req, res) => {
  const limit = parseInt(req.query.limit) || 50;
  const offset = parseInt(req.query.offset) || 0;

  try {
    const rows = db
      .prepare(
        "SELECT * FROM dados_estacao_metereologica ORDER BY id DESC LIMIT ? OFFSET ?"
      )
      .all(limit, offset);
    res.json(rows);
  } catch (error) {
    console.error("Erro ao buscar histórico:", error.message);
    res.status(500).json({ error: "Erro ao buscar histórico de leituras." });
  }
});

/**
 * Tarefa agendada para gerar e salvar previsões meteorológicas a cada hora cheia.
 *
 * Esta função é executada automaticamente pelo `node-cron` no minuto zero de cada hora.
 * O fluxo da tarefa é:
 * 1. Gera as *features* meteorológicas atuais chamando `gerarFeatures()`.
 * 2. Executa o modelo de previsão Python via `gerarPrevisao(features)`.
 * 3. Salva as leituras e a previsão no banco de dados com `salvarUltimoDado(features)`.
 *
 * Em caso de erro em qualquer etapa, o erro é registrado no console.
 *
 * @async
 * @function gerarPrevisaoAgendada
 *
 * @example
 * // Exemplo de execução automática:
 * // No cron: "0 * * * *" → executa todo dia, na hora cheia.
 * // Console output esperado:
 * Gerando nova previsão programada...
 * Nova previsão gerada: { ... }
 * Previsão e dados salvos com sucesso na hora cheia.
 * // Em caso de erro:
 * Erro ao gerar previsão programada: [Error details]
 */
cron.schedule("0 * * * *", async () => {
  console.log("Gerando nova previsão programada...");
  try {
    const features = await gerarFeatures();

    // gera a previsão com os dados atuais
    await gerarPrevisao(features);

    // salva os dados + previsão
    await salvarUltimoDado(features);

    console.log("Previsão e dados salvos com sucesso na hora cheia.");
  } catch (err) {
    console.error("Erro ao gerar previsão programada:", err);
  }
});

/**
 * Inicializa o servidor Express e inicia o agendamento de tarefas.
 *
 * O servidor escuta na porta definida em `PORT` e no endereço "0.0.0.0",
 * permitindo acesso em toda a rede local. Ao iniciar, registra uma mensagem
 * no console confirmando que o servidor está ativo.
 *
 * Também indica que o agendamento de salvamento de previsões a cada hora
 * já foi iniciado pelo cron.
 *
 * @function iniciarServidor
 *
 * @example
 * // Console output esperado após iniciar o servidor:
 * Servidor rodando na rede na porta 4000
 * Agendamento de salvamento a cada hora cheia iniciado
 */
app.listen(PORT, "0.0.0.0", () => {
  console.log(`Servidor rodando na rede na porta ${PORT}`);
});
console.log("Agendamento de salvamento a cada hora cheia iniciado");
